use anyhow::Result;
use sha2::{Sha256, Digest};
use std::collections::HashSet;
use std::fs;
use std::io::Read;
use std::path::Path;

use super::{CheckResult, CurrentEnvironment};
use crate::lockfile::EnvLock;
use crate::utils::{run_command_with_timeout, CommandResult, SHORT_COMMAND_TIMEOUT};

/// Validate bun.lockb binary lockfile
fn validate_bun_lockfile(path: &Path) -> Result<Option<String>> {
    let metadata = fs::metadata(path)?;

    // Check if empty
    if metadata.len() == 0 {
        return Ok(Some("bun.lockb is empty".to_string()));
    }

    // Check magic bytes
    let mut file = fs::File::open(path)?;
    let mut magic = [0u8; 4];

    match file.read_exact(&mut magic) {
        Ok(_) => {
            // Bun lockfiles start with "bun\0" or may have different versioned headers
            // Check for known valid patterns
            if magic.starts_with(b"bun") || is_valid_bun_header(&magic) {
                Ok(None) // Valid
            } else {
                Ok(Some(format!(
                    "bun.lockb has invalid header (expected 'bun\\0', got {:?})",
                    magic
                )))
            }
        }
        Err(e) => Ok(Some(format!("Cannot read bun.lockb header: {}", e))),
    }
}

/// Check if the header bytes represent a valid bun lockfile
/// Bun may use different header versions
fn is_valid_bun_header(header: &[u8; 4]) -> bool {
    // Primary check: starts with "bun"
    if header.starts_with(b"bun") {
        return true;
    }

    // Check for all zeros (corrupted)
    if header == &[0, 0, 0, 0] {
        return false;
    }

    // Check for common text file indicators (wrong format)
    if header.starts_with(b"{\n") || header.starts_with(b"{\r") || header.starts_with(b"# ") {
        return false;
    }

    // Allow other binary patterns (may be valid bun format we don't recognize)
    true
}

/// Read a file with detailed error messages for permission issues
fn read_file_with_permission_check(path: &Path) -> Result<String, String> {
    match fs::read_to_string(path) {
        Ok(content) => Ok(content),
        Err(e) => {
            let msg = match e.kind() {
                std::io::ErrorKind::PermissionDenied => {
                    format!(
                        "Permission denied reading {} - run `chmod 644 {}` or check ownership",
                        path.display(),
                        path.display()
                    )
                }
                std::io::ErrorKind::NotFound => {
                    format!("File not found: {}", path.display())
                }
                _ => format!("Cannot read {}: {}", path.display(), e),
            };
            Err(msg)
        }
    }
}

/// Validate the syntax/integrity of a lockfile
fn validate_lockfile_syntax(lockfile_type: &str) -> Result<Option<String>> {
    match lockfile_type {
        "npm" => {
            let content = match read_file_with_permission_check(Path::new("package-lock.json")) {
                Ok(c) => c,
                Err(e) => return Ok(Some(e)),
            };
            match serde_json::from_str::<serde_json::Value>(&content) {
                Ok(_) => Ok(None),
                Err(e) => Ok(Some(format!("Invalid JSON: {}", e))),
            }
        }
        "pnpm" => {
            let content = match read_file_with_permission_check(Path::new("pnpm-lock.yaml")) {
                Ok(c) => c,
                Err(e) => return Ok(Some(e)),
            };
            match serde_yaml::from_str::<serde_yaml::Value>(&content) {
                Ok(_) => Ok(None),
                Err(e) => Ok(Some(format!("Invalid YAML: {}", e))),
            }
        }
        "yarn" => {
            let content = match read_file_with_permission_check(Path::new("yarn.lock")) {
                Ok(c) => c,
                Err(e) => return Ok(Some(e)),
            };
            // Basic validation for yarn.lock (check common patterns)
            if content.contains("# THIS IS AN AUTOGENERATED FILE") ||
               content.contains("\"@") ||
               content.contains("version \"") {
                Ok(None)
            } else if content.trim().is_empty() {
                Ok(Some("yarn.lock is empty".to_string()))
            } else {
                // If file has content but doesn't match patterns, still consider it valid
                // as yarn.lock format can vary
                Ok(None)
            }
        }
        "bun" => {
            let path = Path::new("bun.lockb");
            match validate_bun_lockfile(path) {
                Ok(None) => Ok(None),
                Ok(Some(err)) => Ok(Some(err)),
                Err(e) => Ok(Some(format!("Cannot read bun.lockb: {}", e))),
            }
        }
        _ => Ok(None),
    }
}

/// Extract all dependency names from package.json
fn extract_package_json_dependencies() -> Result<HashSet<String>> {
    let content = fs::read_to_string("package.json")?;
    let pkg: serde_json::Value = serde_json::from_str(&content)?;

    let mut deps = HashSet::new();

    for field in ["dependencies", "devDependencies", "peerDependencies", "optionalDependencies"] {
        if let Some(obj) = pkg.get(field).and_then(|v| v.as_object()) {
            for key in obj.keys() {
                deps.insert(key.clone());
            }
        }
    }

    Ok(deps)
}

/// Extract dependency names from lockfile
fn extract_lockfile_dependencies(lockfile_type: &str) -> Result<HashSet<String>> {
    let mut deps = HashSet::new();

    match lockfile_type {
        "npm" => {
            let content = fs::read_to_string("package-lock.json")?;
            let lockfile: serde_json::Value = serde_json::from_str(&content)?;

            if let Some(packages) = lockfile.get("packages").and_then(|v| v.as_object()) {
                for key in packages.keys() {
                    // Keys are like "node_modules/react" or "" for root
                    if key.starts_with("node_modules/") {
                        let pkg_name = key.strip_prefix("node_modules/").unwrap();
                        // Handle scoped packages
                        if pkg_name.starts_with('@') {
                            // Take @scope/name
                            let parts: Vec<&str> = pkg_name.splitn(3, '/').collect();
                            if parts.len() >= 2 {
                                deps.insert(format!("{}/{}", parts[0], parts[1]));
                            }
                        } else {
                            // Take first part before any /
                            if let Some(name) = pkg_name.split('/').next() {
                                deps.insert(name.to_string());
                            }
                        }
                    }
                }
            }
            // Fallback to dependencies object for older lockfile versions
            else if let Some(dependencies) = lockfile.get("dependencies").and_then(|v| v.as_object()) {
                for key in dependencies.keys() {
                    deps.insert(key.clone());
                }
            }
        }
        "pnpm" => {
            let content = fs::read_to_string("pnpm-lock.yaml")?;
            let lockfile: serde_yaml::Value = serde_yaml::from_str(&content)?;

            // pnpm lockfile uses "packages" mapping with keys like "name@version"
            if let Some(packages) = lockfile.get("packages").and_then(|v| v.as_mapping()) {
                for key in packages.keys() {
                    if let Some(key_str) = key.as_str() {
                        // Strip leading / and version suffix
                        let pkg_ref = key_str.trim_start_matches('/');
                        if pkg_ref.starts_with('@') {
                            // Scoped package: @scope/name@version
                            let parts: Vec<&str> = pkg_ref.splitn(3, '/').collect();
                            if parts.len() >= 2 {
                                // Second part may contain @version, strip it
                                let name_with_version = parts[1];
                                let name = name_with_version.split('@').next().unwrap_or(name_with_version);
                                deps.insert(format!("{}/{}", parts[0], name));
                            }
                        } else {
                            // Regular package: name@version
                            if let Some(name) = pkg_ref.split('@').next() {
                                if !name.is_empty() {
                                    deps.insert(name.to_string());
                                }
                            }
                        }
                    }
                }
            }
        }
        "yarn" => {
            let content = fs::read_to_string("yarn.lock")?;
            // Parse yarn.lock entries (lines like '"package@version":' or 'package@version:')
            for line in content.lines() {
                let line = line.trim();
                if line.ends_with(':') && !line.starts_with('#') {
                    let entry = line.trim_end_matches(':').trim_matches('"');
                    // Entry is like "react@^18.2.0" or "@scope/pkg@^1.0.0"
                    if entry.starts_with('@') {
                        // Scoped package
                        let parts: Vec<&str> = entry.splitn(3, '/').collect();
                        if parts.len() >= 2 {
                            let name_with_version = parts[1];
                            let name = name_with_version.split('@').next().unwrap_or(name_with_version);
                            deps.insert(format!("{}/{}", parts[0], name));
                        }
                    } else if let Some(name) = entry.split('@').next() {
                        if !name.is_empty() {
                            deps.insert(name.to_string());
                        }
                    }
                }
            }
        }
        "bun" => {
            // bun.lockb is binary, use `bun pm ls` to get installed packages
            if let CommandResult::Success(output) = run_command_with_timeout(
                "bun",
                &["pm", "ls"],
                SHORT_COMMAND_TIMEOUT,
            ) {
                let stdout = String::from_utf8_lossy(&output.stdout);
                // Parse bun pm ls output - format: "├── package@version" or "└── package@version"
                for line in stdout.lines() {
                    let line = line.trim();
                    // Skip empty lines and header
                    if line.is_empty() || line.starts_with('/') {
                        continue;
                    }
                    // Extract package name from lines like "├── react@18.2.0"
                    let pkg_part = line
                        .trim_start_matches("├──")
                        .trim_start_matches("└──")
                        .trim_start_matches("│")
                        .trim();

                    if pkg_part.is_empty() {
                        continue;
                    }

                    // Handle scoped packages (@scope/name@version)
                    if pkg_part.starts_with('@') {
                        // Find the second @ which separates name from version
                        if let Some(at_idx) = pkg_part[1..].find('@') {
                            let name = &pkg_part[..at_idx + 1];
                            deps.insert(name.to_string());
                        }
                    } else if let Some(name) = pkg_part.split('@').next() {
                        if !name.is_empty() {
                            deps.insert(name.to_string());
                        }
                    }
                }
            }
        }
        _ => {}
    }

    Ok(deps)
}

/// Check if package.json dependencies are in sync with lockfile
fn check_package_json_sync(lockfile_type: &str) -> Result<Vec<String>> {
    let pkg_deps = extract_package_json_dependencies()?;
    let lockfile_deps = extract_lockfile_dependencies(lockfile_type)?;

    // Find dependencies in package.json but not in lockfile
    let mut missing: Vec<String> = pkg_deps
        .iter()
        .filter(|dep| !lockfile_deps.contains(*dep))
        .cloned()
        .collect();

    missing.sort();
    Ok(missing)
}

pub fn detect_lockfile() -> Result<(Option<String>, Option<String>)> {
    let lockfiles = [
        ("package-lock.json", "npm"),
        ("yarn.lock", "yarn"),
        ("pnpm-lock.yaml", "pnpm"),
        ("bun.lockb", "bun"),
    ];

    for (filename, lockfile_type) in lockfiles {
        let path = Path::new(filename);
        if path.exists() {
            let hash = compute_file_hash(path)?;
            return Ok((Some(lockfile_type.to_string()), Some(hash)));
        }
    }

    Ok((None, None))
}

pub fn compute_file_hash(path: &Path) -> Result<String> {
    let content = fs::read(path)?;
    let mut hasher = Sha256::new();
    hasher.update(&content);
    let result = hasher.finalize();
    Ok(hex::encode(result))
}

pub fn run_checks(current: &CurrentEnvironment, env_lock: &Option<EnvLock>) -> Result<Vec<CheckResult>> {
    let mut results = Vec::new();

    // Check 1: Lockfile exists
    if current.lockfile_type.is_none() {
        results.push(
            CheckResult::error("Lockfile exists", "lockfile", "No lockfile found")
                .with_fix("Run `npm install` or `pnpm install` to generate one")
        );
        return Ok(results);
    } else {
        results.push(CheckResult::pass("Lockfile exists", "lockfile"));
    }

    // Check 2: Lockfile not corrupted
    if let Some(ref lockfile_type) = current.lockfile_type {
        match validate_lockfile_syntax(lockfile_type) {
            Ok(None) => {
                results.push(CheckResult::pass("Lockfile not corrupted", "lockfile"));
            }
            Ok(Some(error)) => {
                results.push(
                    CheckResult::error(
                        "Lockfile not corrupted",
                        "lockfile",
                        &format!("Lockfile is corrupted: {}", error),
                    )
                    .with_fix("Delete the lockfile and run `npm install` or `pnpm install` to regenerate")
                );
            }
            Err(_) => {
                results.push(
                    CheckResult::error(
                        "Lockfile not corrupted",
                        "lockfile",
                        "Could not read lockfile",
                    )
                    .with_fix("Check file permissions or regenerate the lockfile")
                );
            }
        }
    }

    // Check 3: Lockfile hash matches env.lock
    if let Some(lock) = env_lock {
        if let Some(ref lockfile_info) = lock.lockfile {
            if let Some(ref current_hash) = current.lockfile_hash {
                if current_hash != &lockfile_info.hash {
                    results.push(
                        CheckResult::error(
                            "Lockfile integrity",
                            "lockfile",
                            "Lockfile has changed since env.lock was created",
                        )
                        .with_fix("Run `zenvo lock` to update env.lock, or restore the lockfile")
                    );
                } else {
                    results.push(CheckResult::pass("Lockfile integrity", "lockfile"));
                }
            }
        }
    }

    // Check 3: No duplicate lockfiles
    let lockfile_count = [
        "package-lock.json",
        "yarn.lock",
        "pnpm-lock.yaml",
        "bun.lockb",
    ]
    .iter()
    .filter(|f| Path::new(f).exists())
    .count();

    if lockfile_count > 1 {
        results.push(
            CheckResult::warning(
                "Single lockfile",
                "lockfile",
                "Multiple lockfiles detected - this can cause confusion",
            )
            .with_fix("Remove unused lockfiles, keep only the one for your package manager")
        );
    } else {
        results.push(CheckResult::pass("Single lockfile", "lockfile"));
    }

    // Check 4: package.json exists
    if !Path::new("package.json").exists() {
        results.push(
            CheckResult::error("package.json exists", "lockfile", "No package.json found")
                .with_fix("Run `npm init` or create package.json manually")
        );
    } else {
        results.push(CheckResult::pass("package.json exists", "lockfile"));
    }

    // Check 5: node_modules exists
    if !Path::new("node_modules").exists() {
        results.push(
            CheckResult::warning(
                "node_modules exists",
                "lockfile",
                "node_modules not found - dependencies not installed",
            )
            .with_fix("Run `npm ci` or `pnpm install --frozen-lockfile`")
        );
    } else {
        results.push(CheckResult::pass("node_modules exists", "lockfile"));
    }

    // Check 6: package.json in sync with lockfile
    if let Some(ref lockfile_type) = current.lockfile_type {
        match check_package_json_sync(lockfile_type) {
            Ok(missing) => {
                if missing.is_empty() {
                    results.push(CheckResult::pass("package.json in sync", "lockfile"));
                } else {
                    let msg = if missing.len() <= 3 {
                        format!(
                            "Dependencies in package.json but not in lockfile: {}",
                            missing.join(", ")
                        )
                    } else {
                        format!(
                            "Dependencies in package.json but not in lockfile: {}, and {} more",
                            missing[..3].join(", "),
                            missing.len() - 3
                        )
                    };
                    let fix = match lockfile_type.as_str() {
                        "bun" => "Run `bun install` to update lockfile",
                        "pnpm" => "Run `pnpm install` to update lockfile",
                        "yarn" => "Run `yarn install` to update lockfile",
                        _ => "Run `npm install` to update lockfile",
                    };
                    results.push(
                        CheckResult::warning("package.json in sync", "lockfile", &msg)
                            .with_fix(fix)
                    );
                }
            }
            Err(_) => {
                // If we can't parse, skip the check silently
            }
        }
    }

    Ok(results)
}
