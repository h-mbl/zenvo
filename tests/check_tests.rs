//! Unit tests for Zenvo check modules
//!
//! Tests for lockfile corruption detection, package.json sync, and node_modules matching.

use std::fs;
use tempfile::TempDir;

/// Helper to set up a test project directory
fn setup_test_project() -> TempDir {
    TempDir::new().expect("Failed to create temp directory")
}

/// Helper to create a package.json file
fn create_package_json(dir: &TempDir, content: &str) {
    let path = dir.path().join("package.json");
    fs::write(path, content).expect("Failed to write package.json");
}

/// Helper to create a package-lock.json file
fn create_npm_lockfile(dir: &TempDir, content: &str) {
    let path = dir.path().join("package-lock.json");
    fs::write(path, content).expect("Failed to write package-lock.json");
}

/// Helper to create a pnpm-lock.yaml file
fn create_pnpm_lockfile(dir: &TempDir, content: &str) {
    let path = dir.path().join("pnpm-lock.yaml");
    fs::write(path, content).expect("Failed to write pnpm-lock.yaml");
}

/// Helper to create a yarn.lock file
fn create_yarn_lockfile(dir: &TempDir, content: &str) {
    let path = dir.path().join("yarn.lock");
    fs::write(path, content).expect("Failed to write yarn.lock");
}

// ============================================================================
// Lockfile Corruption Tests
// ============================================================================

#[test]
fn test_valid_npm_lockfile_is_not_corrupted() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    let valid_lockfile = r#"{
        "name": "test-project",
        "version": "1.0.0",
        "lockfileVersion": 3,
        "requires": true,
        "packages": {
            "": {
                "name": "test-project",
                "version": "1.0.0"
            }
        }
    }"#;

    create_npm_lockfile(&dir, valid_lockfile);

    // Parse and verify it's valid JSON
    let content = fs::read_to_string(dir.path().join("package-lock.json")).unwrap();
    let result: Result<serde_json::Value, _> = serde_json::from_str(&content);
    assert!(result.is_ok(), "Valid npm lockfile should parse as JSON");
}

#[test]
fn test_corrupted_npm_lockfile_detected() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    let corrupted_lockfile = r#"{
        "name": "test-project",
        "version": "1.0.0"
        "lockfileVersion": 3  // missing comma
    }"#;

    create_npm_lockfile(&dir, corrupted_lockfile);

    let content = fs::read_to_string(dir.path().join("package-lock.json")).unwrap();
    let result: Result<serde_json::Value, _> = serde_json::from_str(&content);
    assert!(result.is_err(), "Corrupted npm lockfile should fail to parse");
}

#[test]
fn test_valid_pnpm_lockfile_is_not_corrupted() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    let valid_lockfile = r#"lockfileVersion: '9.0'
settings:
  autoInstallPeers: true
packages:
  /react@18.2.0:
    resolution: {integrity: sha512-xxx}
    engines: {node: '>=14'}
"#;

    create_pnpm_lockfile(&dir, valid_lockfile);

    let content = fs::read_to_string(dir.path().join("pnpm-lock.yaml")).unwrap();
    let result: Result<serde_yaml::Value, _> = serde_yaml::from_str(&content);
    assert!(result.is_ok(), "Valid pnpm lockfile should parse as YAML");
}

#[test]
fn test_corrupted_pnpm_lockfile_detected() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // Invalid YAML - bad indentation and structure
    let corrupted_lockfile = r#"lockfileVersion: '9.0'
  settings:  # wrong indentation
autoInstallPeers: true
packages:
  - invalid list item in wrong context
    nested: value
"#;

    create_pnpm_lockfile(&dir, corrupted_lockfile);

    let content = fs::read_to_string(dir.path().join("pnpm-lock.yaml")).unwrap();
    let result: Result<serde_yaml::Value, _> = serde_yaml::from_str(&content);
    assert!(result.is_err(), "Corrupted pnpm lockfile should fail to parse");
}

#[test]
fn test_empty_lockfile_detected() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // Empty file
    create_npm_lockfile(&dir, "");

    let content = fs::read_to_string(dir.path().join("package-lock.json")).unwrap();
    assert!(content.trim().is_empty(), "Empty lockfile should be detected");
}

#[test]
fn test_valid_yarn_lockfile() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    let valid_lockfile = r#"# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

"@babel/core@^7.0.0":
  version "7.23.0"
  resolved "https://registry.yarnpkg.com/@babel/core/-/core-7.23.0.tgz"
  integrity sha512-xxx

react@^18.2.0:
  version "18.2.0"
  resolved "https://registry.yarnpkg.com/react/-/react-18.2.0.tgz"
  integrity sha512-xxx
"#;

    create_yarn_lockfile(&dir, valid_lockfile);

    let content = fs::read_to_string(dir.path().join("yarn.lock")).unwrap();
    // Yarn lockfile validation checks for common patterns
    assert!(
        content.contains("# THIS IS AN AUTOGENERATED FILE") ||
        content.contains("version \""),
        "Valid yarn lockfile should contain expected patterns"
    );
}

// ============================================================================
// Package.json Sync Tests
// ============================================================================

#[test]
fn test_package_json_in_sync_with_lockfile() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    let package_json = r#"{
        "name": "test-project",
        "version": "1.0.0",
        "dependencies": {
            "react": "^18.2.0",
            "lodash": "^4.17.21"
        },
        "devDependencies": {
            "typescript": "^5.0.0"
        }
    }"#;

    let lockfile = r#"{
        "name": "test-project",
        "version": "1.0.0",
        "lockfileVersion": 3,
        "packages": {
            "": {
                "name": "test-project",
                "dependencies": {"react": "^18.2.0", "lodash": "^4.17.21"},
                "devDependencies": {"typescript": "^5.0.0"}
            },
            "node_modules/react": {"version": "18.2.0"},
            "node_modules/lodash": {"version": "4.17.21"},
            "node_modules/typescript": {"version": "5.3.3"}
        }
    }"#;

    create_package_json(&dir, package_json);
    create_npm_lockfile(&dir, lockfile);

    // Parse both files and verify deps are present in lockfile
    let pkg: serde_json::Value = serde_json::from_str(package_json).unwrap();
    let lock: serde_json::Value = serde_json::from_str(lockfile).unwrap();

    let pkg_deps = pkg.get("dependencies").unwrap().as_object().unwrap();
    let lock_packages = lock.get("packages").unwrap().as_object().unwrap();

    for dep_name in pkg_deps.keys() {
        let lock_key = format!("node_modules/{}", dep_name);
        assert!(
            lock_packages.contains_key(&lock_key),
            "Dependency {} should be in lockfile",
            dep_name
        );
    }
}

#[test]
fn test_package_json_missing_from_lockfile() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    let package_json = r#"{
        "name": "test-project",
        "version": "1.0.0",
        "dependencies": {
            "react": "^18.2.0",
            "new-package": "^1.0.0"
        }
    }"#;

    // Lockfile is missing "new-package"
    let lockfile = r#"{
        "name": "test-project",
        "version": "1.0.0",
        "lockfileVersion": 3,
        "packages": {
            "": {"name": "test-project"},
            "node_modules/react": {"version": "18.2.0"}
        }
    }"#;

    create_package_json(&dir, package_json);
    create_npm_lockfile(&dir, lockfile);

    let pkg: serde_json::Value = serde_json::from_str(package_json).unwrap();
    let lock: serde_json::Value = serde_json::from_str(lockfile).unwrap();

    let pkg_deps = pkg.get("dependencies").unwrap().as_object().unwrap();
    let lock_packages = lock.get("packages").unwrap().as_object().unwrap();

    let mut missing_deps = Vec::new();
    for dep_name in pkg_deps.keys() {
        let lock_key = format!("node_modules/{}", dep_name);
        if !lock_packages.contains_key(&lock_key) {
            missing_deps.push(dep_name.clone());
        }
    }

    assert!(!missing_deps.is_empty(), "Should detect missing dependencies");
    assert!(missing_deps.contains(&"new-package".to_string()));
}

// ============================================================================
// Node Modules Matching Tests
// ============================================================================

#[test]
fn test_node_modules_version_extraction() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // Create node_modules/react/package.json
    let react_dir = dir.path().join("node_modules").join("react");
    fs::create_dir_all(&react_dir).unwrap();
    fs::write(
        react_dir.join("package.json"),
        r#"{"name": "react", "version": "18.2.0"}"#,
    )
    .unwrap();

    // Read and verify version
    let pkg_path = react_dir.join("package.json");
    let content = fs::read_to_string(pkg_path).unwrap();
    let pkg: serde_json::Value = serde_json::from_str(&content).unwrap();
    let version = pkg.get("version").and_then(|v| v.as_str()).unwrap();

    assert_eq!(version, "18.2.0");
}

#[test]
fn test_node_modules_version_mismatch_detection() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // Lockfile says react@18.2.0
    let lockfile = r#"{
        "name": "test-project",
        "lockfileVersion": 3,
        "packages": {
            "node_modules/react": {"version": "18.2.0"}
        }
    }"#;

    // But node_modules has react@17.0.2
    let react_dir = dir.path().join("node_modules").join("react");
    fs::create_dir_all(&react_dir).unwrap();
    fs::write(
        react_dir.join("package.json"),
        r#"{"name": "react", "version": "17.0.2"}"#,
    )
    .unwrap();

    create_npm_lockfile(&dir, lockfile);

    // Parse lockfile
    let lock: serde_json::Value = serde_json::from_str(lockfile).unwrap();
    let expected_version = lock
        .get("packages")
        .and_then(|p| p.get("node_modules/react"))
        .and_then(|r| r.get("version"))
        .and_then(|v| v.as_str())
        .unwrap();

    // Read installed version
    let installed_pkg: serde_json::Value = serde_json::from_str(
        &fs::read_to_string(react_dir.join("package.json")).unwrap()
    ).unwrap();
    let installed_version = installed_pkg.get("version").and_then(|v| v.as_str()).unwrap();

    assert_ne!(
        expected_version, installed_version,
        "Should detect version mismatch"
    );
}

#[test]
fn test_scoped_package_handling() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // Create node_modules/@babel/core/package.json
    let babel_dir = dir.path().join("node_modules").join("@babel").join("core");
    fs::create_dir_all(&babel_dir).unwrap();
    fs::write(
        babel_dir.join("package.json"),
        r#"{"name": "@babel/core", "version": "7.23.0"}"#,
    )
    .unwrap();

    let content = fs::read_to_string(babel_dir.join("package.json")).unwrap();
    let pkg: serde_json::Value = serde_json::from_str(&content).unwrap();

    assert_eq!(pkg.get("name").and_then(|v| v.as_str()).unwrap(), "@babel/core");
    assert_eq!(pkg.get("version").and_then(|v| v.as_str()).unwrap(), "7.23.0");
}

// ============================================================================
// Edge Case Tests
// ============================================================================

#[test]
fn test_missing_package_json() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // Don't create package.json
    let result = fs::read_to_string(dir.path().join("package.json"));
    assert!(result.is_err(), "Should fail when package.json is missing");
}

#[test]
fn test_malformed_package_json() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    let malformed = r#"{
        "name": "test-project"
        "version": "1.0.0"  // missing comma
    }"#;

    create_package_json(&dir, malformed);

    let content = fs::read_to_string(dir.path().join("package.json")).unwrap();
    let result: Result<serde_json::Value, _> = serde_json::from_str(&content);
    assert!(result.is_err(), "Should fail to parse malformed package.json");
}

#[test]
fn test_empty_dependencies() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    let package_json = r#"{
        "name": "test-project",
        "version": "1.0.0",
        "dependencies": {},
        "devDependencies": {}
    }"#;

    create_package_json(&dir, package_json);

    let pkg: serde_json::Value = serde_json::from_str(package_json).unwrap();
    let deps = pkg.get("dependencies").and_then(|v| v.as_object()).unwrap();
    let dev_deps = pkg.get("devDependencies").and_then(|v| v.as_object()).unwrap();

    assert!(deps.is_empty(), "dependencies should be empty");
    assert!(dev_deps.is_empty(), "devDependencies should be empty");
}

// ============================================================================
// Node Version Edge Case Tests
// ============================================================================

#[test]
fn test_node_version_with_prerelease() {
    // Test that prerelease versions like "v21.0.0-nightly.20240101" are handled correctly
    let test_cases = vec![
        ("v21.0.0-nightly.20240101", "21.0.0"),
        ("v20.11.0-rc.1", "20.11.0"),
        ("v18.0.0-alpha", "18.0.0"),
        ("v22.0.0-beta.3", "22.0.0"),
        ("v20.5.0-canary.123", "20.5.0"),
        ("20.11.0-nightly", "20.11.0"),
        ("v18.17.0+abc123", "18.17.0"), // build metadata
        ("v20.11.0", "20.11.0"),         // normal version
    ];

    for (input, expected_base) in test_cases {
        let normalized = normalize_version_for_test(input);
        assert!(
            normalized.starts_with(expected_base),
            "Version '{}' should normalize to start with '{}', got '{}'",
            input,
            expected_base,
            normalized
        );
    }
}

/// Helper to normalize version strings (mirrors the logic in toolchain.rs)
fn normalize_version_for_test(version: &str) -> String {
    let version = version.trim().trim_start_matches('v');

    // Check for common suffixes
    let suffixes = [
        "-nightly",
        "-canary",
        "-alpha",
        "-beta",
        "-rc",
        "-pre",
        "-dev",
        "-test",
    ];

    // Find if version contains any suffix at a hyphen boundary
    if let Some(hyphen_idx) = version.find('-') {
        let suffix_part = &version[hyphen_idx..].to_lowercase();

        for suffix in suffixes {
            if suffix_part.starts_with(suffix) {
                return version[..hyphen_idx].to_string();
            }
        }

        // For other hyphens, extract base if valid
        let base = &version[..hyphen_idx];
        let parts: Vec<&str> = base.split('.').collect();
        if parts.len() >= 2 && parts.iter().all(|p| p.parse::<u32>().is_ok()) {
            return base.to_string();
        }
    }

    // Handle plus sign for build metadata
    if let Some(plus_idx) = version.find('+') {
        return version[..plus_idx].to_string();
    }

    version.to_string()
}

#[test]
fn test_semver_constraint_with_partial_versions() {
    // Test that partial versions like ">=18" or "^20" work correctly
    let test_cases = vec![
        (">=18", "20.11.0", true),
        (">=18", "17.9.0", false),
        ("^20", "20.11.0", true),
        ("^20", "21.0.0", false),
        ("~20.11", "20.11.5", true),
        ("~20.11", "20.12.0", false),
        ("*", "20.11.0", true),
        ("x", "18.0.0", true),
    ];

    for (constraint, version, expected) in test_cases {
        let ver = semver::Version::parse(version).unwrap();
        let result = check_constraint_for_test(constraint, &ver);
        assert_eq!(
            result, expected,
            "Constraint '{}' with version '{}' should be {}",
            constraint, version, expected
        );
    }
}

/// Helper to check semver constraints (mirrors logic in toolchain.rs)
fn check_constraint_for_test(constraint: &str, version: &semver::Version) -> bool {
    let constraint = constraint.trim();

    if constraint == "*" || constraint == "x" || constraint == "X" {
        return true;
    }

    if constraint.starts_with(">=") {
        if let Some(min) = parse_version_lenient_for_test(constraint.trim_start_matches(">=").trim()) {
            return version >= &min;
        }
    } else if constraint.starts_with('^') {
        if let Some(base) = parse_version_lenient_for_test(constraint.trim_start_matches('^').trim()) {
            return version.major == base.major && version >= &base;
        }
    } else if constraint.starts_with('~') {
        if let Some(base) = parse_version_lenient_for_test(constraint.trim_start_matches('~').trim()) {
            return version.major == base.major && version.minor == base.minor && version >= &base;
        }
    }

    true
}

fn parse_version_lenient_for_test(version: &str) -> Option<semver::Version> {
    let normalized = normalize_version_for_test(version);

    if let Ok(v) = semver::Version::parse(&normalized) {
        return Some(v);
    }

    let parts: Vec<&str> = normalized.split('.').collect();
    if parts.len() == 2 {
        if let Ok(v) = semver::Version::parse(&format!("{}.0", normalized)) {
            return Some(v);
        }
    }
    if parts.len() == 1 {
        if let Ok(v) = semver::Version::parse(&format!("{}.0.0", normalized)) {
            return Some(v);
        }
    }

    None
}

// ============================================================================
// Scoped Package Deep Path Tests
// ============================================================================

#[test]
fn test_scoped_package_with_deep_path() {
    // Test that "@org/pkg/sub/path" correctly extracts "@org/pkg"
    let test_cases = vec![
        ("@org/pkg", "@org/pkg"),
        ("@org/pkg/sub", "@org/pkg"),
        ("@org/pkg/sub/path", "@org/pkg"),
        ("@babel/core/lib/transform", "@babel/core"),
        ("@types/node/fs", "@types/node"),
        ("lodash/fp/map", "lodash"),
        ("react-dom/client", "react-dom"),
    ];

    for (input, expected) in test_cases {
        let extracted = extract_package_name_from_import(input);
        assert_eq!(
            extracted, expected,
            "Import '{}' should extract package name '{}'",
            input, expected
        );
    }
}

/// Helper to extract package name from import path
fn extract_package_name_from_import(import_path: &str) -> String {
    if import_path.starts_with('@') {
        // Scoped package: @scope/package or @scope/package/subpath
        let parts: Vec<&str> = import_path.splitn(3, '/').collect();
        if parts.len() >= 2 {
            format!("{}/{}", parts[0], parts[1])
        } else {
            import_path.to_string()
        }
    } else {
        // Regular package: package or package/subpath
        import_path.split('/').next().unwrap_or(import_path).to_string()
    }
}

// ============================================================================
// PNPM Workspace Lockfile Tests
// ============================================================================

#[test]
fn test_pnpm_workspace_lockfile() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // pnpm-lock.yaml with importers (workspaces)
    let workspace_lockfile = r#"lockfileVersion: '9.0'
settings:
  autoInstallPeers: true
  excludeLinksFromLockfile: false

importers:
  .:
    dependencies:
      shared-utils:
        specifier: workspace:*
        version: link:packages/shared-utils
    devDependencies:
      typescript:
        specifier: ^5.0.0
        version: 5.3.3

  packages/app:
    dependencies:
      react:
        specifier: ^18.2.0
        version: 18.2.0
      shared-utils:
        specifier: workspace:*
        version: link:../../packages/shared-utils

  packages/shared-utils:
    dependencies:
      lodash:
        specifier: ^4.17.21
        version: 4.17.21

packages:
  /lodash@4.17.21:
    resolution: {integrity: sha512-xxx}
    engines: {node: '>=4'}

  /react@18.2.0:
    resolution: {integrity: sha512-xxx}
    engines: {node: '>=14'}

  /typescript@5.3.3:
    resolution: {integrity: sha512-xxx}
    engines: {node: '>=14.17'}
    hasBin: true
"#;

    create_pnpm_lockfile(&dir, workspace_lockfile);

    let content = fs::read_to_string(dir.path().join("pnpm-lock.yaml")).unwrap();
    let lockfile: serde_yaml::Value = serde_yaml::from_str(&content).unwrap();

    // Verify importers section exists
    assert!(
        lockfile.get("importers").is_some(),
        "pnpm workspace lockfile should have importers section"
    );

    let importers = lockfile.get("importers").unwrap().as_mapping().unwrap();

    // Verify root and workspace packages are present
    assert!(
        importers.get(&serde_yaml::Value::String(".".to_string())).is_some(),
        "Root importer should exist"
    );
    assert!(
        importers.get(&serde_yaml::Value::String("packages/app".to_string())).is_some(),
        "packages/app importer should exist"
    );
    assert!(
        importers.get(&serde_yaml::Value::String("packages/shared-utils".to_string())).is_some(),
        "packages/shared-utils importer should exist"
    );

    // Verify packages section
    let packages = lockfile.get("packages").unwrap().as_mapping().unwrap();
    assert!(packages.len() >= 3, "Should have at least 3 packages");
}

#[test]
fn test_pnpm_workspace_yaml_file() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // Create pnpm-workspace.yaml
    let workspace_config = r#"packages:
  - 'packages/*'
  - 'apps/*'
  - '!**/test/**'
"#;

    let path = dir.path().join("pnpm-workspace.yaml");
    fs::write(&path, workspace_config).unwrap();

    let content = fs::read_to_string(&path).unwrap();
    let workspace: serde_yaml::Value = serde_yaml::from_str(&content).unwrap();

    let packages = workspace.get("packages").unwrap().as_sequence().unwrap();
    assert_eq!(packages.len(), 3, "Should have 3 package patterns");

    let patterns: Vec<&str> = packages
        .iter()
        .filter_map(|v| v.as_str())
        .collect();

    assert!(patterns.contains(&"packages/*"));
    assert!(patterns.contains(&"apps/*"));
    assert!(patterns.contains(&"!**/test/**"));
}

// ============================================================================
// Yarn Berry (v2+) Lockfile Tests
// ============================================================================

#[test]
fn test_yarn_berry_lockfile() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // Yarn Berry (v2+) uses YAML-like format
    let yarn_berry_lockfile = r#"__metadata:
  version: 8
  cacheKey: 10c0

"@babel/core@npm:^7.23.0":
  version: 7.23.5
  resolution: "@babel/core@npm:7.23.5"
  dependencies:
    "@ampproject/remapping": "npm:^2.2.0"
    "@babel/code-frame": "npm:^7.23.5"
  checksum: 10c0/xxx
  languageName: node
  linkType: hard

"react@npm:^18.2.0":
  version: 18.2.0
  resolution: "react@npm:18.2.0"
  dependencies:
    loose-envify: "npm:^1.1.0"
  checksum: 10c0/xxx
  languageName: node
  linkType: hard

"typescript@npm:^5.0.0":
  version: 5.3.3
  resolution: "typescript@npm:5.3.3"
  bin:
    tsc: bin/tsc
    tsserver: bin/tsserver
  checksum: 10c0-xxx
  languageName: node
  linkType: hard
"#;

    create_yarn_lockfile(&dir, yarn_berry_lockfile);

    let content = fs::read_to_string(dir.path().join("yarn.lock")).unwrap();

    // Yarn Berry lockfiles have __metadata section
    assert!(
        content.contains("__metadata:"),
        "Yarn Berry lockfile should contain __metadata section"
    );

    // Should be valid YAML
    let result: Result<serde_yaml::Value, _> = serde_yaml::from_str(&content);
    assert!(
        result.is_ok(),
        "Yarn Berry lockfile should parse as valid YAML"
    );

    let lockfile = result.unwrap();

    // Check metadata version
    let metadata = lockfile.get("__metadata").unwrap();
    assert!(metadata.get("version").is_some(), "Should have version in metadata");

    // Verify package entries exist with npm: prefix format
    assert!(
        content.contains("@npm:"),
        "Yarn Berry lockfile should use npm: resolution format"
    );
}

#[test]
fn test_yarn_classic_vs_berry_detection() {
    // Yarn Classic (v1) uses a custom format
    let yarn_classic = r#"# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

react@^18.2.0:
  version "18.2.0"
  resolved "https://registry.yarnpkg.com/react/-/react-18.2.0.tgz"
  integrity sha512-xxx
"#;

    // Yarn Berry (v2+) uses YAML format with __metadata
    let yarn_berry = r#"__metadata:
  version: 8

"react@npm:^18.2.0":
  version: 18.2.0
  resolution: "react@npm:18.2.0"
"#;

    // Classic detection
    assert!(
        yarn_classic.contains("# yarn lockfile v1"),
        "Should detect Yarn Classic format"
    );
    assert!(
        !yarn_classic.contains("__metadata:"),
        "Yarn Classic should not have __metadata"
    );

    // Berry detection
    assert!(
        yarn_berry.contains("__metadata:"),
        "Should detect Yarn Berry format"
    );
    assert!(
        !yarn_berry.contains("# yarn lockfile v1"),
        "Yarn Berry should not have v1 header"
    );
}

// ============================================================================
// Symlink Edge Case Tests
// ============================================================================

#[test]
fn test_circular_symlinks_in_node_modules() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // Create a node_modules structure
    let node_modules = dir.path().join("node_modules");
    fs::create_dir_all(&node_modules).unwrap();

    // Create a real package
    let pkg_a = node_modules.join("pkg-a");
    fs::create_dir_all(&pkg_a).unwrap();
    fs::write(
        pkg_a.join("package.json"),
        r#"{"name": "pkg-a", "version": "1.0.0"}"#,
    )
    .unwrap();

    // Note: On Windows, creating symlinks requires elevated privileges or developer mode
    // We'll test the symlink resolution logic without actually creating circular symlinks

    // Test that our symlink resolution has a depth limit
    let max_symlink_depth = 10;
    let mut current_depth = 0;
    let path = pkg_a.clone();

    // Simulate following symlinks up to max depth
    while current_depth < max_symlink_depth {
        if path.is_symlink() {
            // In a real scenario, we'd follow the symlink
            // For testing, we just verify the depth limit
            current_depth += 1;
        } else {
            break;
        }
    }

    assert!(
        current_depth < max_symlink_depth,
        "Should not follow symlinks beyond max depth"
    );

    // Verify the package.json is readable
    let pkg_json = fs::read_to_string(pkg_a.join("package.json")).unwrap();
    let pkg: serde_json::Value = serde_json::from_str(&pkg_json).unwrap();
    assert_eq!(pkg.get("name").and_then(|v| v.as_str()).unwrap(), "pkg-a");
}

#[test]
fn test_symlink_resolution_with_relative_paths() {
    let dir = setup_test_project();
    std::env::set_current_dir(dir.path()).unwrap();

    // Create a structure that simulates pnpm's symlink layout
    let node_modules = dir.path().join("node_modules");
    let pnpm_dir = node_modules.join(".pnpm");
    let pnpm_pkg = pnpm_dir.join("react@18.2.0").join("node_modules").join("react");

    fs::create_dir_all(&pnpm_pkg).unwrap();
    fs::write(
        pnpm_pkg.join("package.json"),
        r#"{"name": "react", "version": "18.2.0"}"#,
    )
    .unwrap();

    // Create the symlink target directory (what node_modules/react would point to)
    let react_link = node_modules.join("react");

    // On systems where we can create symlinks, this would be a symlink
    // For testing purposes, we'll just create a regular directory
    fs::create_dir_all(&react_link).unwrap();
    fs::write(
        react_link.join("package.json"),
        r#"{"name": "react", "version": "18.2.0"}"#,
    )
    .unwrap();

    // Verify both locations are readable
    let direct_pkg: serde_json::Value = serde_json::from_str(
        &fs::read_to_string(react_link.join("package.json")).unwrap()
    ).unwrap();

    let pnpm_pkg_json: serde_json::Value = serde_json::from_str(
        &fs::read_to_string(pnpm_pkg.join("package.json")).unwrap()
    ).unwrap();

    assert_eq!(
        direct_pkg.get("version").and_then(|v| v.as_str()),
        pnpm_pkg_json.get("version").and_then(|v| v.as_str()),
        "Versions should match between direct and pnpm store paths"
    );
}

// ============================================================================
// PNPM Package Directory Parsing Tests
// ============================================================================

#[test]
fn test_pnpm_package_directory_parsing() {
    // Test parsing of pnpm's .pnpm directory structure
    let test_cases = vec![
        ("lodash@4.17.21", Some(("lodash", "4.17.21"))),
        ("@types+node@18.19.0", Some(("@types/node", "18.19.0"))),
        ("@babel+core@7.23.5", Some(("@babel/core", "7.23.5"))),
        ("react@18.2.0", Some(("react", "18.2.0"))),
        ("@org+pkg@1.0.0-beta.1", Some(("@org/pkg", "1.0.0-beta.1"))),
        (".modules.yaml", None), // Should skip hidden files
        ("node_modules", None),   // Should skip special directories
        ("registry.npmjs.org+lodash@4.17.21", None), // Registry prefix format (newer pnpm)
    ];

    for (dir_name, expected) in test_cases {
        let result = parse_pnpm_dir_name(dir_name);
        match expected {
            Some((name, version)) => {
                assert!(
                    result.is_some(),
                    "Directory '{}' should parse successfully",
                    dir_name
                );
                let (parsed_name, parsed_version) = result.unwrap();
                assert_eq!(
                    parsed_name, name,
                    "Directory '{}' should have name '{}'",
                    dir_name, name
                );
                assert_eq!(
                    parsed_version, version,
                    "Directory '{}' should have version '{}'",
                    dir_name, version
                );
            }
            None => {
                assert!(
                    result.is_none(),
                    "Directory '{}' should not parse as a package",
                    dir_name
                );
            }
        }
    }
}

/// Helper to parse pnpm directory names
fn parse_pnpm_dir_name(dir_name: &str) -> Option<(String, String)> {
    // Skip directories that don't look like package directories
    if dir_name.starts_with('.') || !dir_name.contains('@') {
        return None;
    }

    // Skip registry prefix format
    if dir_name.contains("registry.") {
        return None;
    }

    // Handle scoped packages (@ in pnpm becomes +)
    if dir_name.contains('+') {
        // Find the last @ which separates name from version
        if let Some(last_at) = dir_name.rfind('@') {
            if last_at > 0 {
                let name_part = &dir_name[..last_at];
                let version = &dir_name[last_at + 1..];

                // Convert + back to / for scoped packages
                let name = name_part.replace('+', "/");

                // Validate version
                if !version.is_empty() && (version.chars().next().map(|c| c.is_ascii_digit()).unwrap_or(false)
                    || version.starts_with("0.")) {
                    return Some((name, version.to_string()));
                }
            }
        }
    } else {
        // Regular package: name@version
        if let Some(at_idx) = dir_name.rfind('@') {
            if at_idx > 0 {
                let name = &dir_name[..at_idx];
                let version = &dir_name[at_idx + 1..];

                if !version.is_empty() && version.chars().next().map(|c| c.is_ascii_digit()).unwrap_or(false) {
                    return Some((name.to_string(), version.to_string()));
                }
            }
        }
    }

    None
}
