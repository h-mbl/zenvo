//! Integration tests for Zenvo CLI commands
//!
//! End-to-end tests for doctor, repair, verify, and init commands.

use assert_cmd::Command;
use predicates::prelude::*;
use std::fs;
use tempfile::TempDir;

/// Helper to get the zenvo binary command
fn zenvo_cmd() -> Command {
    Command::cargo_bin("zenvo").unwrap()
}

/// Check if Node.js is available
fn node_available() -> bool {
    std::process::Command::new("node")
        .arg("--version")
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

/// Helper to set up a test project directory with basic files
fn setup_test_project() -> TempDir {
    let dir = TempDir::new().expect("Failed to create temp directory");

    // Create a minimal package.json
    let package_json = r#"{
        "name": "test-project",
        "version": "1.0.0",
        "dependencies": {
            "lodash": "^4.17.21"
        }
    }"#;
    fs::write(dir.path().join("package.json"), package_json).unwrap();

    // Create a minimal package-lock.json
    let lockfile = r#"{
        "name": "test-project",
        "version": "1.0.0",
        "lockfileVersion": 3,
        "requires": true,
        "packages": {
            "": {
                "name": "test-project",
                "version": "1.0.0",
                "dependencies": {
                    "lodash": "^4.17.21"
                }
            },
            "node_modules/lodash": {
                "version": "4.17.21"
            }
        }
    }"#;
    fs::write(dir.path().join("package-lock.json"), lockfile).unwrap();

    dir
}

/// Helper to create an env.lock file
fn create_env_lock(dir: &TempDir, node_version: &str, pm: &str, pm_version: &str) {
    let env_lock = format!(
        r#"# env.lock - Generated by Zenvo
# DO NOT EDIT MANUALLY - Regenerate with `zenvo lock`

[metadata]
version = "1.0"
generated_at = "2024-01-01T00:00:00Z"
generated_by = "zenvo@0.1.0"

[toolchain]
node = "{}"
package_manager = "{}"
package_manager_version = "{}"

[lockfile]
type = "npm"
hash = "abc123"
"#,
        node_version, pm, pm_version
    );
    fs::write(dir.path().join("env.lock"), env_lock).unwrap();
}

// ============================================================================
// Doctor Command Tests
// ============================================================================

#[test]
fn test_doctor_runs_without_env_lock() {
    let dir = setup_test_project();

    zenvo_cmd()
        .current_dir(dir.path())
        .arg("doctor")
        .assert()
        // Doctor should run but may exit with error if no env.lock
        .stdout(predicate::str::contains("check").or(predicate::str::contains("Running")));
}

#[test]
fn test_doctor_json_output_format() {
    if !node_available() {
        eprintln!("Skipping test: Node.js not available");
        return;
    }

    let dir = setup_test_project();

    let result = zenvo_cmd()
        .current_dir(dir.path())
        .args(["doctor", "--format", "json"])
        .assert();

    // JSON output may go to stdout or stderr depending on success
    let output = result.get_output();
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);
    let combined = format!("{}{}", stdout, stderr);

    assert!(
        combined.contains("\"command\":") ||
        combined.contains("\"success\":") ||
        combined.contains("\"error\":"),
        "Should output JSON: {}", combined
    );
}

#[test]
fn test_doctor_with_category_filter() {
    let dir = setup_test_project();

    zenvo_cmd()
        .current_dir(dir.path())
        .args(["doctor", "--category", "toolchain"])
        .assert()
        // Should run checks for toolchain category
        .stdout(predicate::str::contains("Node").or(predicate::str::contains("check")));
}

#[test]
fn test_doctor_shows_healthy_environment() {
    if !node_available() {
        eprintln!("Skipping test: Node.js not available");
        return;
    }

    let dir = setup_test_project();

    // Create node_modules directory to pass that check
    fs::create_dir_all(dir.path().join("node_modules")).unwrap();
    fs::create_dir_all(dir.path().join("node_modules").join(".bin")).unwrap();

    // Create lodash in node_modules
    let lodash_dir = dir.path().join("node_modules").join("lodash");
    fs::create_dir_all(&lodash_dir).unwrap();
    fs::write(
        lodash_dir.join("package.json"),
        r#"{"name": "lodash", "version": "4.17.21"}"#,
    )
    .unwrap();

    zenvo_cmd()
        .current_dir(dir.path())
        .arg("doctor")
        .assert()
        // Should show pass messages or healthy status
        .stdout(predicate::str::contains("pass")
            .or(predicate::str::contains("✓"))
            .or(predicate::str::contains("healthy"))
            .or(predicate::str::contains("Summary"))
            .or(predicate::str::contains("Running")));
}

// ============================================================================
// Verify Command Tests
// ============================================================================

#[test]
fn test_verify_requires_env_lock() {
    let dir = setup_test_project();
    // Don't create env.lock

    zenvo_cmd()
        .current_dir(dir.path())
        .arg("verify")
        .assert()
        .failure()
        // Should fail because env.lock is missing
        .stderr(predicate::str::contains("env.lock").or(predicate::str::contains("not found")));
}

#[test]
fn test_verify_with_env_lock() {
    if !node_available() {
        eprintln!("Skipping test: Node.js not available");
        return;
    }

    let dir = setup_test_project();

    // Create node_modules
    fs::create_dir_all(dir.path().join("node_modules")).unwrap();

    // Get actual node version for matching
    let node_output = std::process::Command::new("node")
        .arg("--version")
        .output();

    let node_version = match node_output {
        Ok(output) if output.status.success() => {
            String::from_utf8_lossy(&output.stdout)
                .trim()
                .trim_start_matches('v')
                .to_string()
        }
        _ => "20.0.0".to_string(), // fallback version
    };

    // Get npm version
    let npm_output = std::process::Command::new("npm")
        .arg("--version")
        .output();

    let npm_version = match npm_output {
        Ok(output) if output.status.success() => {
            String::from_utf8_lossy(&output.stdout).trim().to_string()
        }
        _ => "10.0.0".to_string(),
    };

    create_env_lock(&dir, &node_version, "npm", &npm_version);

    // This test may fail if environment is different, so just check it runs
    let result = zenvo_cmd()
        .current_dir(dir.path())
        .arg("verify")
        .assert();

    // Either succeeds or fails with meaningful output
    let output = result.get_output();
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);
    let combined = format!("{}{}", stdout, stderr);

    assert!(
        combined.contains("match") ||
        combined.contains("drift") ||
        combined.contains("✓") ||
        combined.contains("✗") ||
        combined.contains("Error") ||
        combined.contains("Zenvo"),
        "Should produce meaningful output: {}", combined
    );
}

#[test]
fn test_verify_strict_mode() {
    if !node_available() {
        eprintln!("Skipping test: Node.js not available");
        return;
    }

    let dir = setup_test_project();
    create_env_lock(&dir, "20.0.0", "npm", "10.0.0");

    let result = zenvo_cmd()
        .current_dir(dir.path())
        .args(["verify", "--strict"])
        .assert();

    // Check combined output
    let output = result.get_output();
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);
    let combined = format!("{}{}", stdout, stderr);

    assert!(
        combined.contains("drift") ||
        combined.contains("match") ||
        combined.contains("ERROR") ||
        combined.contains("WARN") ||
        combined.contains("Error") ||
        combined.contains("Zenvo"),
        "Should produce meaningful output"
    );
}

#[test]
fn test_verify_json_output() {
    if !node_available() {
        eprintln!("Skipping test: Node.js not available");
        return;
    }

    let dir = setup_test_project();
    create_env_lock(&dir, "20.0.0", "npm", "10.0.0");

    let result = zenvo_cmd()
        .current_dir(dir.path())
        .args(["verify", "--format", "json"])
        .assert();

    // Check combined output for JSON
    let output = result.get_output();
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);
    let combined = format!("{}{}", stdout, stderr);

    assert!(
        combined.contains("\"command\":") ||
        combined.contains("\"success\":") ||
        combined.contains("\"error\":"),
        "Should output JSON"
    );
}

// ============================================================================
// Repair Command Tests
// ============================================================================

#[test]
fn test_repair_requires_flag() {
    let dir = setup_test_project();

    zenvo_cmd()
        .current_dir(dir.path())
        .arg("repair")
        .assert()
        // Should show usage info when no flag provided
        .stdout(predicate::str::contains("--plan").or(predicate::str::contains("--apply")));
}

#[test]
fn test_repair_plan_shows_actions() {
    if !node_available() {
        eprintln!("Skipping test: Node.js not available");
        return;
    }

    let dir = setup_test_project();
    create_env_lock(&dir, "20.0.0", "npm", "10.0.0");

    let result = zenvo_cmd()
        .current_dir(dir.path())
        .args(["repair", "--plan"])
        .assert();

    let output = result.get_output();
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);
    let combined = format!("{}{}", stdout, stderr);

    assert!(
        combined.contains("Plan") ||
        combined.contains("healthy") ||
        combined.contains("No issues") ||
        combined.contains("SAFE") ||
        combined.contains("REVIEW") ||
        combined.contains("repair") ||
        combined.contains("Zenvo"),
        "Should show repair plan or message"
    );
}

#[test]
fn test_repair_plan_json_output() {
    if !node_available() {
        eprintln!("Skipping test: Node.js not available");
        return;
    }

    let dir = setup_test_project();
    create_env_lock(&dir, "20.0.0", "npm", "10.0.0");

    let result = zenvo_cmd()
        .current_dir(dir.path())
        .args(["repair", "--plan", "--format", "json"])
        .assert();

    let output = result.get_output();
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);
    let combined = format!("{}{}", stdout, stderr);

    assert!(
        combined.contains("\"command\":") ||
        combined.contains("\"success\":") ||
        combined.contains("\"error\":"),
        "Should output JSON"
    );
}

// ============================================================================
// Init Command Tests
// ============================================================================

#[test]
fn test_init_creates_env_lock() {
    if !node_available() {
        eprintln!("Skipping test: Node.js not available");
        return;
    }

    let dir = setup_test_project();

    let result = zenvo_cmd()
        .current_dir(dir.path())
        .arg("init")
        .assert();

    // Check if it succeeded or produced meaningful output
    let output = result.get_output();
    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);
    let combined = format!("{}{}", stdout, stderr);

    // Either creates file or gives error message
    if dir.path().join("env.lock").exists() {
        assert!(
            combined.contains("env.lock") ||
            combined.contains("created") ||
            combined.contains("initialized") ||
            combined.contains("Generated"),
            "Should confirm env.lock creation"
        );
    } else {
        // If file wasn't created, should have error message
        assert!(
            combined.contains("Error") ||
            combined.contains("error") ||
            combined.contains("failed"),
            "Should show error if not created"
        );
    }
}

#[test]
fn test_init_with_system_info() {
    if !node_available() {
        eprintln!("Skipping test: Node.js not available");
        return;
    }

    let dir = setup_test_project();

    zenvo_cmd()
        .current_dir(dir.path())
        .args(["init", "--system-info"])
        .assert();

    // If env.lock was created, check content
    if dir.path().join("env.lock").exists() {
        let content = fs::read_to_string(dir.path().join("env.lock")).unwrap();
        assert!(
            content.contains("[environment]") ||
            content.contains("os =") ||
            content.contains("[metadata]"),
            "env.lock should contain expected sections"
        );
    }
}

// ============================================================================
// Error Handling Tests
// ============================================================================

#[test]
fn test_command_in_empty_directory() {
    let dir = TempDir::new().unwrap();
    // Empty directory - no package.json

    zenvo_cmd()
        .current_dir(dir.path())
        .arg("doctor")
        .assert()
        // Should handle missing package.json gracefully
        .stdout(predicate::str::contains("check")
            .or(predicate::str::contains("Running"))
            .or(predicate::str::contains("package.json")));
}

#[test]
fn test_invalid_category_handled() {
    let dir = setup_test_project();

    zenvo_cmd()
        .current_dir(dir.path())
        .args(["doctor", "--category", "invalid_category"])
        .assert()
        .failure()
        // Clap now validates against the enum and shows possible values
        .stderr(predicate::str::contains("invalid value")
            .and(predicate::str::contains("possible values"))
            .and(predicate::str::contains("toolchain"))
            .and(predicate::str::contains("lockfile"))
            .and(predicate::str::contains("deps"))
            .and(predicate::str::contains("frameworks")));
}

// ============================================================================
// Help and Version Tests
// ============================================================================

#[test]
fn test_help_command() {
    zenvo_cmd()
        .arg("--help")
        .assert()
        .success()
        .stdout(predicate::str::contains("zenvo").and(predicate::str::contains("doctor")));
}

#[test]
fn test_version_command() {
    zenvo_cmd()
        .arg("--version")
        .assert()
        .success()
        .stdout(predicate::str::contains("zenvo"));
}
